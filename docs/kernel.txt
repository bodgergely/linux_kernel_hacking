General kernel doc
==================
==================


Links
=====

Proc filesystem:
----------------
http://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html





Softirq
=======
interrupt.h
softirq.c

To see softirq changes in action:
$ watch -n 1 cat /proc/softirqs

Interrupts
==========
$ watch -n 0.1 cat /proc/interrupts

Command line params
===================
$ cat /proc/cmdline


Work queues, kworker
===================

linux/workqueue.h
kernel/workqueue.c

static int worker_thread(void *__worker)

Worker threads show up in the process list as: ::

  root      5671  0.0  0.0      0     0 ?        S    12:07   0:00 [kworker/0:1]
  root      5672  0.0  0.0      0     0 ?        S    12:07   0:00 [kworker/1:2]
  root      5673  0.0  0.0      0     0 ?        S    12:12   0:00 [kworker/0:0]
  root      5674  0.0  0.0      0     0 ?        S    12:13   0:00 [kworker/1:0]

If kworkers are going crazy (using too much cpu), there are two types
of possible problems:

	1. Something being scheduled in rapid succession
	2. A single work item that consumes lots of cpu cycles

The first one can be tracked using tracing: ::

	$ echo workqueue:workqueue_queue_work > /sys/kernel/debug/tracing/set_event
	$ cat /sys/kernel/debug/tracing/trace_pipe > out.txt
	(wait a few secs)
	^C

If something is busy looping on work queueing, it would be dominating
the output and the offender can be determined with the work item
function.

For the second type of problems it should be possible to just check
the stack trace of the offending worker thread. ::

	$ cat /proc/THE_OFFENDING_KWORKER/stack

The work item's function should be trivially visible in the stack
trace.


Block I/O layer (mostly from the Rober Love book)
===============

Types:
    - Character
    - Block

Char devs access a stream of sequential data, one byte after the another.
E.g: serial ports, keyboards
If a hardware dev is implemented as a stream of data -> it is a char dev.

Block device accesses data randomly (non-sequenctially) NOT as a stream.
E.g: hard drive

Char dev is much simpler as only the current pos in the stream needs to be
looked at. 

Entire subsystem is dedicated to block devices. (char devs do not get their own)
This subsystem is called the Block I/O Layer.

Block device
------------

- Smallest addressable unit is the `sector`. 512 bytes for a sector is the most common
size.
The device cannot address or operate on a unit smaller than the sector, 
although many block devices can operate on multiple sectors at one time.

In software world it is called a `block`. The smallest addressable unit.
The `block` is an abstraction of the filesystem, filesystems can be accessed
only in multiple of a block. Although the physical device is addressable at the
sector level, the kernel performs all disk operations in terms of blocks.
Block cannot be larger than the page size. 
Therefore, block sizes are a power-of-two multiple of the sector size and
are not greater than the page size. Common block sizes are 512 bytes, 1 kilobyte, and 4
kilobytes.

`sector` vs `block`: sector is the hardware unit, block is the software unit of filesystem.
`block` is an abstarction built on sectors.


Buffers
-------

Pending writes/reads are stored in buffers. Buffers are associated with blocks. Block is 
composed of one or more sectors.

`struct buffer_head` describes the buffer in <linux/buffer_head.h>.

Nowadays the basic I/O unit is the `struct bio` in <linux/blk_types.h>.





Page Cache
==========

Links:
https://www.thomas-krenn.com/en/wiki/Linux_Page_Cache_Basics

Utils:
- free - Display amount of free and used memory in the system
$ free -m
             total        used        free      shared  buff/cache   available
Mem:         15638        3399        4397         613        7840       11395
Swap:         2047           0        2047


Force page cache clearing:
$ echo 1 > /proc/sys/vm/drop_caches



Kernel tuning
=============

https://www.linuxtopia.org/online_books/linux_kernel/kernel_configuration/ch09s03.html

CONFIG_PREEMPT - for low latency
it is usually not set for desktops CONFIG_PREEMTP_VOLUNTARY

